\documentclass[10pt, a4paper]{article}
\usepackage{a4wide}
\usepackage{polski}
\usepackage{url}
\usepackage[utf8]{inputenc}
\usepackage{amsthm}
\usepackage{amssymb}

\usepackage{semantic}

\newtheorem{zadanie}{Zadanie}

\linespread{0.9}

\author{}
\title{Seminarium: Programowanie w teorii typów}

\begin{document}

\begin{center}
\begin{Large}
\textsc{Seminarium: programowanie w teorii typów}
\end{Large}
\end{center}

\paragraph{\underline{1. Proste przykłady zastosowań typów zależnych w Agdzie}}

\begin{itemize}
\addtolength{\itemsep}{-0.5\baselineskip}
\item
    Przykłady funkcji spełniających proste specyfikacje (np. filter, o której przez konstrukcję wiemy, że zwraca podlistę listy wejściowej [1])
\item
    Przykłady struktur danych zachowujących proste niezmienniki, które normalnie istniałyby tylko w głowie implementującego (np. drzewa BST [2])
\item
    Ilustracja mocy wyrazu typów zależnych, która pozwala na napisanie programu ładniejszego w porównaniu do tego, który byłby napisany w Haskellu lub MLu [3].

\end{itemize}

\subparagraph{Literatura:}

\begin{enumerate}
\addtolength{\itemsep}{-0.5\baselineskip}
 \item  Dependently Typed Programming in Agda - Ulf Norell
 \item  Dependent Types at Work - Ana Bove and Peter Dybjer
 \item  CPDT. Chapter 7. More Dependent Types. A Tagless Interpreter - Adam Chlipała (tutaj dostarczymy tłumaczenie programu na Agdę).
\end{enumerate}

\paragraph{\underline{2. Piękno i elegancja typów zależnych}}

\begin{itemize}
 \item 
Pokazanie przykładów z klasycznych prac, które demonstrują ważne i praktyczne zastosowania typów zależnych ([1], [2]). Głównym trzonem prezentacji powinna być raczej praca [1] i należałoby przedstawić pełną konstrukcję otrzymanego ostatecznego programu razem z rozumowaniem/ideą, która za nią stoi.
\end{itemize}

\subparagraph{Literatura:}

\begin{enumerate}
\addtolength{\itemsep}{-0.5\baselineskip}

 \item Why Dependent Types Matter - McBride, McKinna, Swierstra
 \item The Power of pi - Swierstra, Oury
\end{enumerate}

\paragraph{\underline{3. Gdy rekursja strukturalna może nie wystarczać}}
~ \\

Prezentacja problemu i kilku technik radzenia sobie sobie w sytuacjach, gdy naiwna implementacja nie spełnia rygorystycznych wymagań języka co do dozwolonych schematów rekursji:

\begin{itemize}
\addtolength{\itemsep}{-0.5\baselineskip}

 \item 
    dodanie dodatkowego argumentu - limitu rekurencyjnych wywołań [1]
 \item 
    indukcja względem indeksu indeksowanej struktury danych [2]
 \item 
    odkrycie struktury względem której faktycznie chcielibyśmy zrobić indukcję i zmaterializowanie jej w postaci typu indukcyjnego [1,2,3,4]
 \item 
    dobrze ufundowana indukcja: teoria i praktyka [1,5,6]
 \item 
    (opcjonalnie) wspomnienie o ogólnej rekursji w oparciu o prace Any Bove [7] (chociaż sam przykład użycia indukcji-rekursji jako rozszerzenia jednej z powyższych technik)

\end{itemize}

\subparagraph{Literatura:}

\begin{enumerate}
\addtolength{\itemsep}{-0.5\baselineskip}

 \item
     Coq’Art. Chapter 15. General recursion.

\item
    Unification by structural induction - McBride
\item
    Why Dependent Types Matter - McBride, McKinna, Swierstra
\item
    Strong Functional Programming - Turner
\item
    Slajdy o dobrze ufundowanej indukcji w Agdzie Erica Mertensa
\item
    Biblioteka standardowa Agdy - Induction.WellFounded
\item
    General Recursion in Type Theory - A. Bove
\item
    Constructing Recursion Operators in Intuitionistic Type Theory
 
\end{enumerate}


\paragraph{\underline{4. Koindukcja}} 

\begin{itemize}
\addtolength{\itemsep}{-0.5\baselineskip}

 \item Czym jest koindukcja?
 \item Przykłady wnioskowań przed koindukcję i programów definiowanych przez korekursję.
 \item Używanie koindukcji w Agdzie\footnote{
Chodzi nam o Agdę 2.2.10 i nowsze. We wcześniejszych wersjach używało się słowa kluczowego codata - chcemy posłuchać o aktualnym sposobie (wbudowane operacje SHARP i FLAT, patrz [2], [3], [4]).
}. Guarded coinduction. Implementacja klasycznych koindukcyjnych struktur danych - strumienie, kolisty, nieskończone drzewa binarne.
 \item Techniki pozwalające radzić sobie, gdy naturalna (naiwna) implementacja nie jest akceptowana przez Agdę, gdyż wykracza poza schemat guarded coinduction. [3,5]
 \item Definicje indukcyjno-koindukcyjne: przykłady zastosowań [3,4]
\end{itemize}

\subparagraph{Literatura:}

\begin{enumerate}
\addtolength{\itemsep}{-0.5\baselineskip}
 \item Strong Functional Programming - David Turner
 \item Artykuł o koinducji na Agda wiki: \\ {\small
       \url{http://wiki.portal.chalmers.se/agda/pmwiki.php?n=ReferenceManual.Codatatypes}
      }
 \item Mixing Induction and Coinduction - Nils Anders Danielsson, Thorsten Altenkirch
 \item Total Parser Combinators - Nils Anders Danielsson
 \item Beating the Productivity Checker Using Embedded Languages - Nils Anders Danielsson
\end{enumerate}

\subparagraph{Literatura dodatkowa:}

\begin{enumerate}
\addtolength{\itemsep}{-0.5\baselineskip}
 \item General Recursion via Coinductive Types - Venanzio Capretta
 \item Certified Programming with Dependent Types (Chapter 5. Infinite Data and Proofs) - Adam Chlipała
 \item Coq’Art (Rozdział 13.) - Yves Bertot, Pierre Castéran.
\end{enumerate}

\paragraph{\underline{5. Widoki}}

\begin{itemize}
\addtolength{\itemsep}{-0.5\baselineskip}
 \item Pojęcie widoku w ujęciu “klasycznym”, czyli w kontekście języków funkcyjnych [1].
 \item Przedstawienie widoków jako rozszerzenia kompilatora GHC dla Haskella [2].
 \item Wytłumaczenie, dlaczego widoki w kontekście programowania z typami zależnymi nabierają rumieńców [3].
 \item Przedstawienie różnych przykładów struktur danych i widoków dla nich [3,4,5].
\end{itemize}

\subparagraph{Literatura:}

\begin{enumerate}
\addtolength{\itemsep}{-0.5\baselineskip}
 \item Views: A way for pattern matching to cohabit with data abstraction - Wadler (1986)
 \item A new view of guards - Peyton Jones (www, 1997)
 \item The view from the left - McBride, McKinna
 \item Strong Functional Programming - Turner
 \item Why Dependent Types Matter - McBride, McKinna, Swierstra
\end{enumerate}

\paragraph{\underline{6. Reprezentacja języków z wiązaniem zmiennych}}

\begin{itemize}
\addtolength{\itemsep}{-0.5\baselineskip}
 \item Różne podejścia do reprezentacji wiązań. 
 \item Dlaczego nie wystarcza nam naiwna reprezentacja (np. zmienne reprezentowane poprzez typ string)? 
 \item (Opcjonalnie) jak wygląda sprawa dowodzenia twierdzeń na temat języka z konstrukcjami wiążącymi zmienne (np. lambda abstrakcje)?
\end{itemize}

\subparagraph{Literatura:}

\begin{enumerate}
\addtolength{\itemsep}{-0.5\baselineskip}
 \item CPDT - Adam Chlipala
 \item Parametric Higher-Order Abstract Syntax for Mechanized Semantics - Adam Chlipala
 \item Nameless, Painless - Nicolas Pouillard
 \item A fresh look at programming with names and binders - Nicolas Pouillard, François Pottier
 \item Strongly-typed term representations in Coq - N. Benton, Ch.-K. Hur, A. Kennedy, C. McBride
 \item Name binding blog: \\
       \url{http://namebinding.wordpress.com/}
\end{enumerate}

\paragraph{\underline{7. Typy zależne w Haskellu}}

\begin{itemize}
\addtolength{\itemsep}{-0.5\baselineskip}
 \item Omówienie (tak powszechnie używanych, że już częściowo zastąpionych przez nowsze pomysły) rozszerzeń Haskella 98 [1], które potrzebne będą, aby zrozumieć pracę [2].
 \item Pokazanie jak można symulować typy zależne w Haskellu za pomocą wieloparametrycznych klas typów i zależności funkcyjnych [2].
 \item Przedstawienie uogólnionych typów algebraicznych (GADT). Porównanie ich możliwości z rodzinami indukcyjnymi z Agdy.
 \item Przedstawienie SHE, czyli próby dorobienia pewnych elementów typów zależnych do Haskella (język… tłumaczony do Haskella!) [3,4]
\end{itemize}

\subparagraph{Literatura:}

\begin{enumerate}
\addtolength{\itemsep}{-0.5\baselineskip}

 \item Type classes with functional dependencies - Mark P. Jones (2000)
 \item Faking It: Simulating Dependent Types in Haskell - Conor McBride (2001) 
 \item The Strathclyde Haskell Enhancement
 \item Wykład 1. z kursu Dependently Typed Programming używający SHE jako ilustracji
 \item Materiały internetowe, m.in. \\
       \url{http://en.wikibooks.org/wiki/Haskell/GADT}

\end{enumerate}

\paragraph{\underline{8. Programowanie generyczne}}


\begin{itemize}
\addtolength{\itemsep}{-0.5\baselineskip}

\item Użycie uniwersów do pisania algorytmów niezależących od konkretnego typu danych.
\item Uniwersum dla prostych typów indukcyjnych, wraz z przykładowymi programami jak generyczna równość, generyczny map.
\item Bardziej zaawansowane kodowania: rodziny indukcyjne, kontenery, zippery itp.
\item Pisanie funkcji z różną arnością (eliminacja problemu z powtarzaniem schematu zipWith, zipWith3, itd) [5].
\item (Opcjonalnie) Zastosowanie mechanizmu w praktyce: Generyczny i certyfikowany algorytm diff [1].

\end{itemize}

\subparagraph{Literatura:}


\begin{enumerate}
\addtolength{\itemsep}{-0.5\baselineskip}

\item  Type-safe Diff for Families of Datatypes - E. Lempsink, S. Leather, A. Loh
\item  Generic programming with Dependent Types - T. Altenkirch, C. McBride, P. Morris
\item  Generic programming with Indexed Functors - A. Loh, J. P. Magalhaes
\item  Constructing Universes for Generic Programming - P. Morris
\item  Arity-Generic Datatype-Generic Programming - S. Weirich, C.Casinghino
\item  Exploring the regular tree type -

\end{enumerate}

\paragraph{\underline{9. Przegląd innych systemów z typami zależnymi}}

\begin{itemize}
\addtolength{\itemsep}{-0.5\baselineskip}
 \item Przykłady: IDRIS, ATS (następnik Dependent ML), F*
 \item Chodziłoby o zapoznanie się z tymi systemami i pokazaniu jakie są ich cele i możliwości.
 \item Temat wstępnie zarezerwowany dla gościa.
\end{itemize}


\section{xxx}



Przykłady: 

Chodziłoby o zapoznanie się z tymi systemami i pokazaniu jakie są ich cele i możliwości.
Opis: 

Literatura:    
    
\paragraph{\underline{x}}

\begin{itemize}
\addtolength{\itemsep}{-0.5\baselineskip}

 \item 
\end{itemize}

\subparagraph{Literatura:}

\begin{enumerate}
\addtolength{\itemsep}{-0.5\baselineskip}

 \item 
\end{enumerate}

\end{document}


