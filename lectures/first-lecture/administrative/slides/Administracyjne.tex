\documentclass{beamer}

% wygląd slajdów 
% \usetheme{Warsaw} 
\usetheme{Boadilla}

% \usecolortheme{seahorse} 

% brak tej dziwnej nawigacji w prawym dolnym rogu 
\setbeamertemplate{navigation symbols}{} 

% brak zbędnych informacji w stopce
\setbeamertemplate{footline}[page number]{}

% klikalne linki
\usepackage{hyperref}

% kodowanie utf8 
%\usepackage[OT4]{fontenc} 
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc} 
\usepackage[polish]{babel} 
\usepackage{listings}

% konfiguracja niektórych parametrów 
% \setbeamercovered{transparent} 
\setbeamertemplate{bibliography item}[text] 
\setlength{\parskip}{1ex} 
\setlength{\parindent}{0pt} 

\title{Seminarium: Programowanie w teorii typów}
\subtitle{Sprawy organizacyjne}
%\author{Dariusz Biernacki, Wojciech Jedynak, Paweł Wieczorek} 
%\institute{Instytut Informatyki Uniwersytetu Wrocławskiego}

\AtBeginSection[]
{
   \begin{frame}
       \frametitle{}
       \tableofcontents[sectionstyle=show/hide, subsectionstyle=show/show/hide]
   \end{frame}
}

\begin{document}

%\lstset{language=Lisp}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{Plan spotkania}

\begin{itemize}

\item Omówienie spraw organizacyjnych
\item Krótka prezentacja praktycznych możliwości typów zależnych 
\item Przypomnienie idei Izomorfizmu Curry'ego-Howarda

\end{itemize}

% \tableofcontents[hidesubsections]
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{Sprawy organizacyjne}

\tableofcontents[hidesubsections]

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%

\section{Cel seminarium}

\begin{frame}

\frametitle{Co chcemy osiągnąć?}

\begin{itemize}
\item Chcemy nauczyć się programować i dowodzić przy użyciu typów zależnych w języku Agda
\item Chcemy zrozumieć klasyczny system teoretyczny, który za tym stoi
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%

\section{Wymagania wstępne}

\begin{frame}

\frametitle{Jakie są wymagania wstępne?}

\begin{itemize}
\item Znajomość jakiegoś typowanego języka funkcyjnego
\item Podstawowa znajomość zagadnień związanych z typami i rachunkiem lambda
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Ogólny plan seminarium}

\begin{frame}

\frametitle{Plan seminarium}

\begin{itemize}

\item Tydzień 1. Spotkanie organizacyjne + wstęp teoretyczny

\begin{itemize}
\item <2-4> Omówienie spraw organizacyjnych
\item <3-4> Krótka prezentacja praktycznych możliwości typów zależnych
\item <4-4> Przypomnienie idei Izomorfizmu Curry'ego-Howarda
\end{itemize}

\item Tygodnie 2-3. Teoria Martina-Lofa

\begin{itemize}
\item <5-5> Paweł i Wojtek omówią polimorficzną teorię typów Martina-Lofa.
\end{itemize}

\item Tydzień 4. Zapoznanie z Agdą

\begin{itemize}
\item <6-7> Wprowadzenie do Agdy
\item <7-7> Porównanie klasycznej teorii i tego co mamy w Agdzie
\end{itemize}

\item Tygodnie 5-15. Prezentacje tematów wolnych
\begin{itemize}
\item <8-> Mamy listę proponowanych tematów, ale sprawa jest otwarta
%% Pierwsza prezentacja studencka powinna omawiać prace:
%%   Why Dependent Types Matter - McBride, McKinna, Swierstra
%%   Power of Pi - Swierstra
%% To trzeba na liście tematów chyba zaznaczyc
\end{itemize}

\end{itemize}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%

\section{Oczekiwania, kryteria oceny}

\begin{frame}

\frametitle{Czego oczekujemy?}

\begin{itemize}
\item Bardzo dobrej frekwencji -- dozwolone 3 nieobecności \pause

\item Przygotowania porządnej prezentacji - będą one oceniane \pause

\item Przygotowania przykładowego kodu w Agdzie do prezentacji \pause

\item Nieobowiązkowe listy zadań

\end{itemize}

%% \begin{block}{Przygotowania przykładowego kodu w Agdzie do prezentacji}
%%   Kod ma pokazywać dane zagadnienie w praktyce lub implementować algorytm z pracy.
%%   (Np. jeśli praca dotyczy ciekawego schematu rekursji, to chcemy zobaczyć i potem sami potestować programy, w którym to się nam faktycznie przydaje).
%% \end{block}

%% \pause

%% \end{itemize}

%% \begin{block}{Nieobowiązkowe listy zadań}
%%   Do części teoretycznej i praktycznej (Agda) będą przygotowane ćwiczenia.
%%   Będzie można je rozwiązać na papierze, a część sprawdzić w Agdzie. 
%%   Będą one nieobowiązkowe, ale jeśli ktoś podeśle nam swoje
%%   rozwiązania (e-mail? moodle?) przed podanym deadlinem to je sprawdzimy i skomentujemy.
%% \end{block}


\end{frame}

\section{Lista proponowanych tematów, literatura}

\begin{frame}

\frametitle{Proponowane tematy, literatura}

\begin{itemize}

\item Materiały rozdane (będą dostępne na stronie wykładu) \pause
\item Do tematów TODO TODO TODO najlepiej zgłaszać się już niedługo, 
żeby mieć czas na przygotowanie się.

\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%% OLD STUFF %%%%%%%

%% \section{Kontynuacje - wstęp}

%% \subsection{Próba zdefiniowania kontynuacji}
%% \begin{frame}[fragile]
%% \frametitle{Wprowadzenie}

%% \begin{block}{Czym są kontynuacje?}
%% Kontynuacje pojawiają się podczas procesów obliczeniowych. \\
%% W każdym momencie procesu reprezentują obliczenia, które zostaną wykonane w przyszłości. \\
%% Możemy o nich również myśleć jak o migawkach (ang. snapshot) danego stadium obliczenia. 
%% \end{block}
%% \end{frame}


%% \subsection{Rozgrzewkowy przykładzik}
%% \begin{frame}[fragile]
%% \frametitle{Przykład na rozgrzewkę}
%% \begin{itemize} 
%% \item <1-> Chcemy napisać funkcję, która obliczy iloczyn wszystkich elementów podanej listy
%% \item <2-> Jeśli w liście występuje 0, to wynik jest również 0 i szkoda wykonywać jakiekolwiek mnożenia
%% \end{itemize}

%% \pause
%% \pause
%% \begin{lstlisting}
%% (define (product lst)
%%   (define (loop l k)
%%     (cond ((null? l) (k 1))
%%           ((= 0 (car l)) 0)
%%           (else (loop (cdr l)
%%                       (lambda (x)
%%                          (k (* x (car l))))))))
%%   (loop lst (lambda (x) x)))
%% \end{lstlisting}
%% \end{frame}

%% \begin{frame}[fragile]
%% \frametitle{Przykład na rozgrzewkę cd.}
%% \begin{itemize} 
%% \item <1-> Przerobiliśmy funkcję na wersję z tzn. named let
%% \end{itemize}

%% \pause
%% \begin{lstlisting}
%% (define (product lst)
%%   (let loop ((l lst) 
%%              (k (lambda (x) x)))
%%     (cond ((null? l) (k 1))
%%           ((= 0 (car l)) 0)
%%           (else (loop (cdr l)
%%                       (lambda (x) 
%%                         (k (* x (car l)))))))))
%% \end{lstlisting}
%% \end{frame}

%% \section{Continuation Passing Style (CPS)}

%% \subsection{Definicja}
%% \begin{frame}[fragile]
%% \frametitle{Continuation Passing Style}

%% \begin{itemize} 
%% \item <1-> CPS to styl programowania funkcyjnego, w którym sterowanie jest przekazywane jawnie jako kontynuacja
%% \item <2-> W praktyce polega to na rozszerzeniu wszystkich funkcji o dodatkowy argument - kontynuację - do którego zwracane są
%% wszystkie wyniki
%% \end{itemize}
%% \end{frame}

%% \subsection{Przykładowa transformacja do CPS}
%% \begin{frame}[fragile]
%% \frametitle{Przykładowa transformacja do CPS}

%% \begin{itemize} 
%% \item <1-> Chcemy przekształcić proste wyrażenie arytmetyczne na CPS
%% \begin{lstlisting}
%% (+ 2 (* 8 (+ 2 3)))         ;;  42
%% \end{lstlisting}

%% \item <2-> Potrzebujemy operatorów arytmetycznych w wersji CPS
%% \begin{lstlisting}
%% (define (k+ a b k)
%%   (k (+ a b)))

%% (define (k* a b k)
%%   (k (* a b)))

%% (define (return x)
%%   x)
%% \end{lstlisting}

%% \end{itemize}
%% \end{frame}

%% \begin{frame}[fragile]
%% \frametitle{Przykładowa transformacja do CPS cd.}

%% \begin{itemize} 
%% \item <1-> \begin{lstlisting}
%% (+ 2 (* 8 (+ 2 3))) 
%% \end{lstlisting}

%% \item <1-> Musimy teraz wywinąć wyrażenia 'na drugą stronę' - działanie 2+3 jest wykonywane jako pierwsze!
%% \begin{lstlisting}
%% (k+ 2 3 (lambda (x) 
%%           (k* 8 x (lambda (y)
%%                     (k+ 2 y return)))))
%% \end{lstlisting}
%% \end{itemize}
%% \end{frame}

%% \subsection{Zalety i wady CPS}
%% \begin{frame}[fragile]
%% \frametitle{Zalety i wady CPS}

%% CPS jest przyjemny, bo:
%% \begin{itemize} 
%% \item <2-> W każdym momencie mamy możliwość przerwania obliczeń
%% \item <3-> Transformacja programu do CPS upraszcza kompilację: nie trzeba odkładać funkcji na stos, bo wszystkie wywołania są ogonowe
%% \end{itemize}
%% \pause
%% \pause
%% \pause
%% Ludzie nie są jednak kompilatorami:
%% \begin{itemize} 
%% \item <5-> kod staje się trudniejszy do zrozumienia
%% \item <6-> i mniej czytelny: pałętają się dodatkowe lambdy i kontynuacje
%% \end{itemize}
%% \pause
%% \pause
%% \pause
%% \begin{block}{Dobra wiadomość}
%% W Scheme mamy wygodniejsze kontynuacje!
%% \end{block}
%% \end{frame}


%% \section{Kontynuacje w Scheme}

%% \subsection{call-with-current-continuation}
%% \begin{frame}[fragile]
%% \frametitle{Kontynuacje w Scheme}

%% \begin{itemize} 
%% \item <1-> W Scheme obsługa kontynuacji jest wbudowana
%% \end{itemize}
%% \pause
%% \begin{block}{operator call/cc}
%% (call-with-current-continuation proc) \\
%% w skrócie: \\
%% (call/cc proc) 
%% \end{block}

%% \begin{itemize} 
%% \item <3-> proc powinno być jednoargumentową procedurą; w miejsce argumentu automagicznie zostanie wstawiona bieżąca kontynuacja
%% \end{itemize}
%% \end{frame}

%% \subsection{call/cc w praktyce}

%% \begin{frame}[fragile]
%% \frametitle{Elementarne przykłady}

%% \begin{itemize} 
%% \item <1-> Nie mamy obowiązku użyć kontynuacji otrzymanej od call/cc, nie widzimy wtedy różnicy w porównaniu ze zwykłym lispem
%% \end{itemize}
%% \begin{lstlisting}
%% (* 3 (call/cc (lambda (k) (+ 2 1)))) 
%% ;; 9
%% \end{lstlisting}
%% \begin{itemize} 
%% \item <2-> Jednak jesli wywolamy k, to wyskakujemy natychmiast
%% \end{itemize}
%% \pause
%% \begin{lstlisting}
%% (* 3 (call/cc (lambda (k) (+ 1 (k 2)))))
%% ;; 6 
%% \end{lstlisting}
%% \end{frame}

%% \begin{frame}[fragile]
%% \frametitle{Elementarne przykłady cd.}

%% \begin{itemize} 
%% \item <1-> Kontynuacje zachowują się jak normalne wartości lispowe; w szczególności możemy przypisać je do zmiennych
%% \end{itemize}
%% \pause
%% \begin{lstlisting}
%% (define a #f) (define b #f)
%% (define (c-in-c)
%%   (* 3 (call/cc (lambda (k1)
%%           (+ 2 (call/cc (lambda (k2)
%%                   (set! a k1)
%%                   (set! b k2)
%%                   2)))))))
%% (c-in-c) ;; 12
%% (a 1) ;; 3
%% (b 1) ;; 9
%% \end{lstlisting}
%% \end{frame}


%% \section{Moc call/cc}

%% \subsection{Wyskakiwanie z funkcji}
%% \begin{frame}[fragile]
%% \frametitle{Wyskakiwanie z funkcji}
%% \begin{itemize} 
%% \item <2-> Przykład: przeglądanie listy aż do znalezienia odpowiedniego elementu z pozostałych
%% \end{itemize}
%% \pause
%% \pause
%% \begin{lstlisting}
%% (define (search wanted? lst) 
%%    (call/cc 
%%      (lambda (return) 
%%        (for-each (lambda (element) 
%%                    (if (wanted? element) 
%%                        (return element))) 
%%                  lst) 
%%        \#f)))
%% \end{lstlisting}
%% \end{frame}


%% \subsection{Wskakiwanie do funkcji}
%% \begin{frame}[fragile]
%% \frametitle{Wskakiwanie do funkcji}
%% \begin{itemize} 
%% \item <2-> Wariant poprzedniego przykładu: znalezioną wartość przekazujemy do podanej procedury
%% \end{itemize}
%% \pause
%% \pause
%% \begin{lstlisting}
%% (define (treat element like-it) 
%%   (if (good-element? element) 
%%       (like-it 'fnord))) 
%% \end{lstlisting}
%%   \pause
%% \begin{lstlisting}
%% (define (search2 treat lst) 
%%   (call/cc 
%%    (lambda (return) 
%%      (for-each (lambda (element) 
%%                  (treat element return)) 
%%                lst) 
%%      \#f))) 
%% \end{lstlisting}
%% \end{frame}



%% \subsection{Coroutines}
%% \begin{frame}[fragile]
%% \frametitle{Coroutines}
%% \begin{block}{Implementacja przeplatanych procedur za pomocą call/cc}
%% coroutines.ss
%% \end{block}
%% \end{frame}


%% \subsection{Amb i programowanie logiczne}
%% \begin{frame}[fragile]
%% \frametitle{Niedeterminizm w Scheme - operator amb}

%% \begin{itemize} 
%% \item <2-> Intuicyjnie: (amb a b c ..) zwraca w niedeterministyczny sposób jeden z argumentów
%% \item <3-> Dodatkowo, amb zawsze wybiera ten wariant, który nie kończy się porażką!
%% \end{itemize}

%% \pause
%% \pause
%% \pause
%% \begin{block}{(Wciąż intuicyjna) semantyka operatora amb}
%% (amb a) zwraca a \\
%% (amb)    oznacza porażkę $\rightarrow$ wykonuje nawrót \\
%% (amb a b ... z)  zwraca pierwszy z argumentów, który nie kończy się porażką
%% \end{block}
%% \end{frame}

%% \begin{frame}[fragile]
%% \frametitle{amb w praktyce}
%%   \pause
%% \begin{lstlisting}
%% (amb (amb) (amb 1 2) 3 4)
%% ;; 1
%% \end{lstlisting}
%%   \pause
%% \begin{lstlisting}
%% (amb)
%% ;; 2
%% \end{lstlisting}
%%   \pause
%% \begin{lstlisting}
%% (amb)
%% ;; 3
%% \end{lstlisting}
%%   \pause
%% \begin{lstlisting}
%% (amb)
%% ;; 4
%% \end{lstlisting}
%%   \pause
%% \begin{lstlisting}
%% (amb)
%% ;; no-more-values
%% \end{lstlisting}
%% \end{frame}

%% \begin{frame}[fragile]
%% \frametitle{Programowanie logiczne}
%% \begin{itemize} 
%% \item <2-> Dzięki amb możemy w Scheme rozwiązywać zagadki Prologowe
%% \end{itemize}
%% \pause
%% \pause
%% \begin{block}{Implementacja amb i przykładowy program logiczny}
%% amb.ss
%% \end{block}
%% \end{frame}




%% \section{Podsumowanie}
%% \subsection{Zagadka}
%% \begin{frame}[fragile]
%% \frametitle{Zagadka do domu}
%% \begin{lstlisting}

%% \end{lstlisting}
%% \begin{block}{Co będzie wypisywane na ekran?}
%% (let ((yin \\
%%  \ \ \ \ \ \         ((lambda (cc) (display \#\textbackslash@) cc) (call/cc (lambda (c) c)))) \\
%%  \ \ \      (yang \\
%%  \ \ \ \ \ \          ((lambda (cc) (display \#\textbackslash* cc) (call/cc (lambda (c) c))))) \\ 
%%     (yin yang)) 
%% \end{block}
%% \begin{block}{Plik z zagadką}
%% yin-yang-zagadka.ss
%% \end{block}
%% \end{frame}

%% \subsection{Literatura}
%% \begin{frame}[fragile]
%% \frametitle{Literatura}
%% \begin{itemize}
%% \item <1->Yet Another Scheme Tutorial, rozdziały 16. i 18.
%% (\url{http://www.shido.info/lisp/scheme\_cc\_e.html} i \url{http://www.shido.info/lisp/scheme\_amb\_e.html})
%% \item <1->A short introduction to call-with-current-continuation
%% (\url{http://community.schemewiki.org/?call-with-current-continuation})
%% \item <1->\url{http://en.wikipedia.org/wiki/Call-with-current-continuation}
%% \end{itemize}
%% \end{frame}

\end{document}
