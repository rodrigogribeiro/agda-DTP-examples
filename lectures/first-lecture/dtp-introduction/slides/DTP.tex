\documentclass{beamer}

% wygląd slajdów 
% \usetheme{Warsaw} 
\usetheme{Boadilla}

% \usecolortheme{seahorse} 

% brak tej dziwnej nawigacji w prawym dolnym rogu 
\setbeamertemplate{navigation symbols}{} 

% brak zbędnych informacji w stopce
\setbeamertemplate{footline}[page number]{}

% klikalne linki
\usepackage{hyperref}

% kodowanie utf8 
%\usepackage[OT4]{fontenc} 
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc} 
\usepackage[polish]{babel} 
\usepackage{listings}

% konfiguracja niektórych parametrów 
% \setbeamercovered{transparent} 
\setbeamertemplate{bibliography item}[text] 
\setlength{\parskip}{1ex} 
\setlength{\parindent}{0pt} 

\title{Seminarium: Programowanie w teorii typów}
\subtitle{Przykładowe zastosowania typów zależnych}
\author{Wojciech Jedynak, Paweł Wieczorek} 
\institute{Instytut Informatyki Uniwersytetu Wrocławskiego}

\AtBeginSection[]
{
   \begin{frame}
       \frametitle{}
       \tableofcontents[sectionstyle=show/hide, subsectionstyle=show/show/hide]
   \end{frame}
}

\begin{document}

\lstset{language=Haskell}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%

% \tableofcontents[hidesubsections]

%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Na początku był Haskell...}
\subsection{...i wszystko było dobrze...}

\begin{frame}

\frametitle{Programowanie funkcyjne - mocne strony}

\begin{itemize}
\item Programując w silnie typowanym języku funkcyjnym mamy gwarancję,
że jeśli kompilator zaakceptuje nasz program, to wykluczone zostały
pewne klasy błędów programistycznych 
% (użycie liczby w miejsce napisu, 
% dereferencja pustego wskaźnika, zwolnenienie błędnego obszaru pamięci
\item Co z błędami logicznymi?
\item Używając sprytu i doświadczenia możemy sobie pomóc...
% przykłady: listy parzystej dlugości
% regularne drzewa binarne
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{...prawie wszystko.}

\begin{frame}[fragile]
\frametitle{Typ bool nie ma znaczenia!}

W klasycznym programowaniu funkcyjnym typecheckerowi jest obojętne
jaki będzie rezultat obliczenia predykatu w wyrażeniu warunkowym.

\begin{lstlisting}
if null xs then 
  head xs 
else 
  xs
\end{lstlisting}


``Well-typed programs can't go wrong''?

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% \section{Programowanie z typami zależnymi - We can do it better.}

%% %%%%%%%%%%%%%%%%%%%%%%%

% \subsection{Słaba moc wyrazu specyfikacji typowych}

\begin{frame}[fragile]
\frametitle{Informacyjność typów - podejście ``tradycyjne''}

W Haskellu piszemy:

\begin{lstlisting}
sort :: Ord a => [a] -> [a]
\end{lstlisting}

Co możemy wywnioskować z takiej sygnatury? A czego {\bf nie} możemy wywnioskować?

% słaba specyfikacja...

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Typy zależne - motywacja}

\begin{frame}
\frametitle{Na czym polega programowanie z typami zależnymi?}

\begin{itemize}

\item Programowanie w typami zależnymi opiera się na programowaniu funkcyjnym
\item Dostajemy do dyspozycji znacznie bardziej rozbudowany system typów
\item Główne hasło: \emph{typ} wyrażenia może {\bf zależeć} od jego \emph{wartości}
\item System wystarczająco silny, by mówić o {\bf certyfikacji}

\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{Wyrażanie własności danych}

Systemy, którymi będziemy się tutaj zajmować pozwalają
wyrażać właśności takie jak: 

\begin{itemize}
\item liczba n jest parzysta
\item lista l jest posortowana
\item drzewo t jest zbalansowane
\item plik f jest otwarty
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Czy możemy lepiej?}

\begin{frame}[fragile]
\frametitle{Informacyjność typów - typy zależne}

Używając typów zależnych możemy napisać (pseudokod)

\begin{lstlisting}
sort :: Ord a => (xs : [a]) -> 
  (ys : [a] && ordered ys && permutation_of xs ys)
\end{lstlisting}

% uwaga: możemy nazwać argumenty w sygnaturze!

Co możemy wywnioskować z takiej sygnatury?

% wyjściowa lista jest posortowana
% jest permutacją listy wejściowej
% program się zakończy!

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{Zastowanie praktyczne: projektowanie API}

Gdy projektujemy interfejs dla biblioteki 
rzadko udaje się wyrazić wszystkie założenia w sygnaturach.

\begin{block}{Przykład. Kółko i krzyżyk}
Zaprojektuj interfejs dla operacji addMove i undo, zapytania
empty? i wartości empty. Przeanalizuj relacje między nimi.
\end{block}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{Projektowanie API c.d.}

Stosując tradycyjne podejście pewne założenia musimy
(w najlepszym wypadku) wyrazić jako komentarz...

\begin{block}{Dobra wiadomość}
Typy zależne pozwalają nam traktować dowody na równi z wartościami.
Możemy programować i dowodzić w ramach tego samego systemu!
\end{block}

%% TODO zaprojektować na kartce ostateczne API, które chcę pokazaćo

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{Uwagi}

Żeby cała ta zabawa miała sens, logika, która jest wbudowana w
język pozwalający na programowanie z typami zależnymi musi być niesprzeczna.

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{Większe przykłady}

\begin{itemize}

\item Drzewa poszukiwań binarnych z niezmiennikiem
\item Unifikacja pierwszego rzędu
\end{itemize}

\end{frame}

\end{document}
